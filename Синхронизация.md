
**Synchronized**

Если использовать synchronized на нескольких методах, то только один поток сможет делать эти методы в один момент времени, допустим читать и изменять значение. 

Каждый объект в Java имеет связанный с ним монитор. Когда поток входит в синхронизированный блок или метод, он захватывает монитор этого объекта. Если монитор уже занят другим потоком, текущий поток будет ждать его освобождения.


**Volatile**

Ключевое слово Volatile гарантирует, что изменение переменной будет видно другим потокам. Запись в Volatile happens before чтение из Volatile.

Паттерн `Immutable`

Полезен когда необходимо сделать volatile сложный объект, коллекцию, например. Суть паттерна в том что вместо изменения коллекции мы добавляем туда элементы, которые никогда не будут меняться.

Atomic и принцип CAS 

Атомарная операция — это операция, которая выполняется полностью или не выполняется совсем, частичное выполнение невозможно.

Пакет `java.util.concurrent.atomic` содержит набор классов, которые поддерживают составные атомарные действия над одним значением без блокировок, подобно `volatile`.  

С помощью этого принципа можно сделать систему с большим уровнем гарантий безопасности, чем на Volatile.

### Synchronized и ReentrantLock

Synchronized это конструкция, которая может быть оптимизирована языком. Если JVM подумает, что монитор можно не захватывать, она может пропустить эту операцию и не заблокировать объект, с ReentraneLock такого случиться не может.

### CountDownLatch

  
CountDownLatch (замок с обратным отсчетом) это счётчик, который потоки могут уменьшать и кода счётчик достигает 0, потоки продолжат свою работу

