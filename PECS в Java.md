Producer Extends Consumer Super

Если у нас есть некая коллекция, типизированная wildcard с верхней границей (_extends_) – то это, «продюсер». «Он только «продюсирует», предоставляет элемент из контейнера, а сам ничего не принимает». Если же у нас коллекция, типизированная wildcard по нижней границе (_super_) – то это, «потребитель», который «только принимает, а предоставить ничего не может».

Wildcard с super не может вернуть ничего кроме класса Object

**Какие объекты можно получить из** `List<? extends Class3> list`?
Из данного списка можно получить только объекты суперклассов.

Во время компиляции кода неизвестно, объекты какого именно класса будут содержаться в листе. Допустим, это будут объекты Class3. Тогда в этой строке

```
Class4 class4 = list.get(0);
```

мы получим объект класса-предка и попытаемся положить его в переменную, имеющую тип класса-потомка, чего Java конечно же сделать неявно не позволит.

Почему в `List<? extends Class3> list` нельзя положить объекты суперклассов (Class0, Class1, Class2), думаю, очевидно: негоже объекту-наследнику ссылаться на объект-предок.
Но что нам мешает, добавить в `List<? extends Class3> list` объект типа Class4 или Class5?
В момент компиляции JVM не знает, что во время выполнения программы будет скрываться под маской `List<? extends Class3>`. Может это будет `List<Class4>`, а может быть `List<Class100500>`. И если это действительно окажется `List<Class100500>`, а вы будете добавлять туда элемент, имеющий тип Class3 или Class4, это будет неверно.

`List<? super Class3>` гарантирует, что при любом раскладе в листе будут объекты имеющие тип не «младше» класса Class3. Поэтому туда можно класть объект любого класса потомка



