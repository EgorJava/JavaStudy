В языке Java поток представляется в виде объекта-потомка класса Thread. Этот класс инкапсулирует стандартные механизмы работы с потоком.

Способы запустить поток
###### Способ 1

  
Создать объект класса Thread, передав ему в конструкторе нечто, реализующее интерфейс Runnable. Этот интерфейс содержит метод run(), который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод run().

###### Способ 2

  
Создать потомка класса Thread и переопределить его метод run():

#### Interruption
Первый способ — вызвать метод bool isInterrupted() объекта потока, второй — вызвать статический метод bool Thread.interrupted(). Первый метод возвращает состояние флага прерывания и оставляет этот флаг нетронутым. Второй метод возвращает состояние флага и сбрасывает его.

#### Метод Thread.sleep()

  
Thread.sleep() — статический метод класса Thread, который приостанавливает выполнение потока, в котором он был вызван. Во время выполнения метода sleep() система перестает выделять потоку процессорное время, распределяя его между другими потоками. Метод sleep() может выполняться либо заданное кол-во времени (миллисекунды или наносекунды) либо до тех пор пока он не будет остановлен прерыванием (в этом случае он сгенерирует исключение InterruptedException).
#### Метод yield()

  
Статический метод Thread.yield() заставляет процессор переключиться на обработку других потоков системы. Метод может быть полезным, например, когда поток ожидает наступления какого-либо события и необходимо чтобы проверка его наступления происходила как можно чаще. В этом случае можно поместить проверку события и метод Thread.yield() в цикл
#### Метод join()

  
В Java предусмотрен механизм, позволяющий одному потоку ждать завершения выполнения другого. Для этого используется метод join(). Например, чтобы главный поток подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() в главном потоке. Как только поток myThready завершится, метод join() вернет управление, и главный поток сможет продолжить выполнение.  
  
Метод join() имеет перегруженную версию, которая получает в качестве параметра время ожидания. В этом случае join() возвращает управление либо когда завершится ожидаемый поток, либо когда закончится время ожидания. Подобно методу Thread.sleep() метод join может ждать в течение миллисекунд и наносекунд – аргументы те же.

Синхронизация.

Если использовать synchronized на нескольких методах, то только один поток сможет делать эти методы в один момент времени, допустим читать и изменять значение. 

Каждый объект в Java имеет связанный с ним монитор. Когда поток входит в синхронизированный блок или метод, он захватывает монитор этого объекта. Если монитор уже занят другим потоком, текущий поток будет ждать его освобождения.

## Методы wait(), notify() и notifyAll()

Методы `wait()`, `notify()`, и `notifyAll()` — это инструменты для координации работы между потоками, которые используют общие ресурсы. Они вызываются на объекте класса, который реализует интерфейс `Object`, и должны использоваться только в синхронизированных блоках или методах.

- `wait()` заставляет текущий поток ожидать до тех пор, пока другой поток не вызовет `notify()` или `notifyAll()` на том же объекте.
    
- `notify()` пробуждает один случайно выбранный поток, который ожидает на этом объекте.
    
- `notifyAll()` пробуждает все потоки, которые ожидают на этом объекте.

`InterruptedException` — это исключение, которое выбрасывается, когда другой поток прерывает текущий поток, пока тот находится в состоянии ожидания. Правильный способ обработки этого исключения — это выставить флаг прерывания обратно и завершить выполнение, если это уместно:

Доступ управляется с помощью счётчика: изначально значение счётчика равно `int permits`, когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из блока.

#### CountDownLatch

  
CountDownLatch (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор, пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены», чтобы продолжить свою деятельность. В конструктор CountDownLatch (`CountDownLatch(int count)`) обязательно передается количество операций, которое должно быть выполнено, чтобы замок «отпустил» заблокированные потоки.

Блокировка потоков снимается с помощью счётчика: любой действующий поток, при выполнении определенной операции уменьшает значение счётчика. Когда счётчик достигает 0, все ожидающие потоки разблокируются и продолжают выполняться.


#### CyclicBarrier

  
CyclicBarrier реализует шаблон синхронизации [Барьер](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F). Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». В конструктор барьера (`CyclicBarrier(int parties)` и `CyclicBarrier(int parties, Runnable barrierAction)`) обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».

#### Exchanger<V>

  
Exchanger (обменник) может понадобиться, для того, чтобы обменяться данными между двумя потоками в определенной точки работы обоих потоков. Обменник — обобщенный класс, он параметризируется типом объекта для передачи.

Обменник является точкой синхронизации пары потоков: поток, вызывающий у обменника метод `exchange()` блокируется и ждет другой поток. Когда другой поток вызовет тот же метод, произойдет обмен объектами: каждая из них получит аргумент другой в методе `exchange()`. Стоит отметить, что обменник поддерживает передачу `null` значения. Это дает возможность использовать его для передачи объекта в одну сторону, или, просто как точку синхронизации двух потоков.

#### Phaser

  
Phaser (фазер), как и CyclicBarrier, является реализацией шаблона синхронизации [Барьер](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F), но, в отличии от CyclicBarrier, предоставляет больше гибкости. Этот класс позволяет синхронизировать потоки, представляющие отдельную фазу или стадию выполнения общего действия. Как и CyclicBarrier, Phaser является точкой синхронизации, в которой встречаются потоки-участники. Когда все стороны прибыли, Phaser переходит к следующей фазе и снова ожидает ее завершения.  
  
Если сравнить Phaser и CyclicBarrier, то можно выделить следующие важные особенности Phaser:  

- Каждая фаза (цикл синхронизации) имеет номер;
- Количество сторон-участников жестко не задано и может меняться: поток может регистрироваться в качестве участника и отменять свое участие;
- Участник не обязан ожидать, пока все остальные участники соберутся на барьере. Чтобы продолжить свою работу достаточно сообщить о своем прибытии;
- Случайные свидетели могут следить за активностью в барьере;
- Поток может и не быть стороной-участником барьера, чтобы ожидать его преодоления;
- У фазера нет опционального действия.

Основные методы:  

- **int register()** — регистрирует нового участника, который выполняет фазы. Возвращает номер текущей фазы;
- **int getPhase()** — возвращает номер текущей фазы;
- **int arriveAndAwaitAdvance()** — указывает что поток завершил выполнение фазы. Поток приостанавливается до момента, пока все остальные стороны не закончат выполнять данную фазу. Точный аналог `CyclicBarrier.await()`. Возвращает номер текущей фазы;
- **int arrive()** — сообщает, что сторона завершила фазу, и возвращает номер фазы. При вызове данного метода поток не приостанавливается, а продолжает выполнятся;
- **int arriveAndDeregister()** — сообщает о завершении всех фаз стороной и снимает ее с регистрации. Возвращает номер текущей фазы;
- **int awaitAdvance(int phase)** — если phase равно номеру текущей фазы, приостанавливает вызвавший его поток до её окончания. В противном случае сразу возвращает аргумент.

Volatile

Определение ключевого слова "своими словами":

> Ключевое слово `volatile` используется для обозначения  
> переменных, которые могут быть изменены несколькими потоками. Оно  
> гарантирует, что изменения переменной видны другим потокам.

Если копнуть глубже в JMM, найдём такое определение:

> Запись в `volatile` переменную `happens-before` каждое последующее чтение той же самой переменной (A write to a volatile variable `v` happens-before all subsequent reads of `v` by any thread).

Исходя из определения `volatile`, чтение примитива или ссылки всегда будут соответствовать последнему записанному значению без использования каких-либо блокировок, как по монитору объекта и т.п.


Lock-free

Если пометить переменную как `volatile`, то не нужно осуществлять никаких блокировок для чтения и записи примитива или ссылки.

Паттерн `Immutable`

Полезен когда необходимо сделать volatile сложный объект, коллекцию, например. Суть паттерна в том что вместо изменения коллекции мы добавляем туда элементы, которые никогда не будут меняться.

Atomic и принцип CAS 

Атомарная операция — это операция, которая выполняется полностью или не выполняется совсем, частичное выполнение невозможно.

Пакет `java.util.concurrent.atomic` содержит набор классов, которые поддерживают составные атомарные действия над одним значением без блокировок, подобно `volatile`.  
  
Используя классы AtomicXXX, можно реализовать атомарную операцию `check-then-act`

Принцип CAS (Compare-and-Swap) в Java — это атомарная операция, которая позволяет сравнить значение переменной с ожидаемым значением и, если они совпадают, обновить переменную новым значением. Это обеспечивает потокобезопасность и синхронизацию в многопоточных приложениях без использования блокировок.
Операция CAS включает три параметра: 
1. Адрес ячейки памяти (V).
2. Ожидаемое старое значение (A).
3. Новое значение (B).

Процесс:

1. Текущее значение в указанной ячейке памяти сравнивается с ожидаемым значением.
2. Если сравнение успешно, новое значение атомарно записывается в ячейку памяти.
3. Если сравнение не удалось, операция считается неудачной, что сигнализирует, что значение в ячейке памяти было изменено другим потоком.

Метод compareAndSet в классах CAS сравнивает текущее значение с ожидаемым и, если они совпадают, заменяет его на новое значение. Если значения не совпадают, метод вернёт false, и попытку нужно повторить снова.

Lock  
  
Пакет `java.util.concurrent.locks` имеет стандартный интерфейс `Lock`. Реализация `ReentrantLock` дублирует функциональность ключевого слова synchronized, но также предоставляет дополнительные функции, такие как получение информации о состоянии блокировки, неблокирующий `tryLock()` и прерываемая блокировке. 